<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Oracle Pro | Advanced Prediction System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #6a11cb;
            --secondary: #2575fc;
            --dark: #1a1a2e;
            --darker: #16213e;
            --light: #f8f9fa;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #fd7e14;
            --info: #17a2b8;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --glow: 0 0 15px rgba(106, 17, 203, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, var(--dark), var(--darker));
            color: var(--light);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeIn 1s ease-in-out;
        }

        .logo {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: var(--glow);
        }

        .subtitle {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 20px;
        }

        .dev-credit {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 5px;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .card-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title i {
            font-size: 1.4rem;
        }

        .info-section {
            margin-bottom: 30px;
        }

        .info-item {
            display: flex;
            margin-bottom: 10px;
            align-items: center;
        }

        .info-item i {
            margin-right: 10px;
            color: var(--secondary);
            width: 20px;
            text-align: center;
        }

        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .control-panel {
                grid-template-columns: 1fr;
            }
        }

        select, button {
            width: 100%;
            padding: 12px 15px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 15px center;
            background-size: 15px;
        }

        select:focus, button:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--primary);
        }

        button {
            background: linear-gradient(to right, var(--primary), var(--secondary));
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .result-display {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .result-display::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                rgba(106, 17, 203, 0.1),
                rgba(37, 117, 252, 0.1),
                transparent
            );
            transform: rotate(30deg);
            z-index: 0;
        }

        .period-info {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }

        .timer {
            font-size: 1rem;
            color: var(--secondary);
            margin-bottom: 15px;
            font-weight: 600;
        }

        .prediction-result {
            font-size: 1.8rem;
            font-weight: 700;
            margin: 15px 0;
            color: white;
            position: relative;
            z-index: 1;
        }

        .prediction-short {
            font-size: 3rem;
            font-weight: 900;
            margin: 20px 0;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: var(--glow);
        }

        .probability {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 10px;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tabs button {
            background: none;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
            position: relative;
            border-radius: 0;
            flex: 1;
            text-align: center;
        }

        .tabs button.active {
            color: white;
        }

        .tabs button.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
        }

        .history-content {
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .history-content::-webkit-scrollbar {
            width: 5px;
        }

        .history-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .history-content::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 5px;
        }

        .history-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            align-items: center;
            transition: all 0.3s ease;
        }

        .history-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .history-item div {
            display: flex;
            flex-direction: column;
        }

        .history-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 5px;
        }

        .history-value {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .status-win {
            color: var(--success);
        }

        .status-loss {
            color: var(--danger);
        }

        .status-pending {
            color: var(--warning);
        }

        .color-dot {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .color-red {
            background-color: var(--danger);
            box-shadow: 0 0 10px var(--danger);
        }

        .color-green {
            background-color: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .server-info {
            display: none;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin-top: 10px;
            animation: fadeIn 0.5s ease-out;
        }

        .server-info.active {
            display: block;
        }

        .server-info p {
            margin-bottom: 10px;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .server-info ul {
            padding-left: 20px;
            margin-bottom: 10px;
        }

        .server-info li {
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .how-to-use {
            margin-top: 30px;
        }

        .how-to-use h3 {
            margin-bottom: 15px;
            color: var(--secondary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .how-to-use ol {
            padding-left: 20px;
        }

        .how-to-use li {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(106, 17, 203, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(106, 17, 203, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(106, 17, 203, 0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .floating {
            animation: floating 3s ease-in-out infinite;
        }

        @keyframes floating {
            0% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
            100% {
                transform: translateY(0px);
            }
        }

        .glow-text {
            text-shadow: 0 0 10px currentColor;
        }

        /* Responsive adjustments */
        @media (max-width: 576px) {
            .logo {
                font-size: 1.8rem;
            }
            
            .history-item {
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }
            
            .history-item div {
                grid-column: span 1;
            }
            
            .card-title {
                font-size: 1rem;
            }
            
            .prediction-result {
                font-size: 1.4rem;
            }
            
            .prediction-short {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 class="logo floating">Quantum Oracle Pro</h1>
            <p class="subtitle">Advanced AI-Powered Prediction System</p>
            <p class="dev-credit">ìÜ©ùêÄ·¥Öx_ùêÉ·¥áÃ∏·¥†Ã¥D·¥ÄÃ∑ Ä·¥ãÃ¥ üú≤ìÜ™ ()</p>
        </header>

        <div class="card info-section">
            <h2 class="card-title"><i class="fas fa-info-circle"></i> System Status</h2>
            <div class="info-item">
                <i class="fas fa-server"></i>
                <span>API Connection: <span id="apiStatus">Connected</span></span>
            </div>
            <div class="info-item">
                <i class="fas fa-bolt"></i>
                <span>Last Refresh: <span id="lastRefresh">Just now</span></span>
            </div>
            <div class="info-item">
                <i class="fas fa-chart-line"></i>
                <span>Accuracy Rate: <span id="accuracyRate">Calculating...</span></span>
            </div>
        </div>

        <div class="card">
            <h2 class="card-title"><i class="fas fa-cogs"></i> Control Panel</h2>
            <div class="control-panel">
                <div>
                    <label for="serverSelect">Prediction Engine:</label>
                    <select id="serverSelect" onchange="updateServerSelection()">
                        <option value="">Select Engine</option>
                        <option value="neural">Neural Quantum Engine</option>
                        <option value="fractal">Fractal Pattern Scanner</option>
                        <option value="chaos">Chaos Theory Analyzer</option>
                        <option value="temporal">Temporal Flux Predictor</option>
                        <option value="holo">Holographic AI Matrix</option>
                    </select>
                    
                    <div id="neuralInfo" class="server-info">
                        <p><strong>Neural Quantum Engine:</strong> Uses quantum-inspired neural networks to analyze probability waves across multiple dimensions.</p>
                        <ul>
                            <li>Best for: Short-term predictions</li>
                            <li>Accuracy: 85-92%</li>
                            <li>Specialty: Detects micro-patterns</li>
                        </ul>
                    </div>
                    <div id="fractalInfo" class="server-info">
                        <p><strong>Fractal Pattern Scanner:</strong> Identifies repeating fractal patterns in historical data to predict future outcomes.</p>
                        <ul>
                            <li>Best for: Volatile periods</li>
                            <li>Accuracy: 82-88%</li>
                            <li>Specialty: Pattern recognition</li>
                        </ul>
                    </div>
                    <div id="chaosInfo" class="server-info">
                        <p><strong>Chaos Theory Analyzer:</strong> Applies chaos mathematics to find order in apparent randomness.</p>
                        <ul>
                            <li>Best for: Long sequences</li>
                            <li>Accuracy: 80-87%</li>
                            <li>Specialty: Breaking streaks</li>
                        </ul>
                    </div>
                    <div id="temporalInfo" class="server-info">
                        <p><strong>Temporal Flux Predictor:</strong> Uses time-series analysis to predict temporal anomalies in results.</p>
                        <ul>
                            <li>Best for: Trend reversals</li>
                            <li>Accuracy: 83-90%</li>
                            <li>Specialty: Timing predictions</li>
                        </ul>
                    </div>
                    <div id="holoInfo" class="server-info">
                        <p><strong>Holographic AI Matrix:</strong> Advanced holographic principle analysis of the entire data field.</p>
                        <ul>
                            <li>Best for: All conditions</li>
                            <li>Accuracy: 87-94%</li>
                            <li>Specialty: Highest accuracy</li>
                        </ul>
                    </div>
                </div>
                <div>
                    <label for="resultType">Prediction Type:</label>
                    <select id="resultType">
                        <option value="bigsmall">Big/Small</option>
                        <option value="redgreen">Red/Green</option>
                    </select>
                </div>
            </div>
            
            <button onclick="forceRefresh()" class="pulse">
                <i class="fas fa-sync-alt"></i> Force Refresh
            </button>
        </div>

        <div class="card result-display">
            <div class="period-info">
                <span id="period">Period: Loading...</span>
            </div>
            <div class="timer" id="timer">Time: --s</div>
            <div class="prediction-result" id="currentResult">Awaiting Engine Selection</div>
            <div class="prediction-short" id="predictionShort">-</div>
            <div class="probability" id="probability">Probability: --%</div>
        </div>

        <div class="card">
            <h2 class="card-title"><i class="fas fa-history"></i> History</h2>
            <div class="tabs">
                <button onclick="fetchData(1, 'game')" class="active">Game Results</button>
                <button onclick="fetchData(1, 'my')">My Predictions</button>
                <button onclick="fetchData(1, 'chart')">Analytics</button>
            </div>
            <div class="history-content" id="historyContent">
                Loading history data...
            </div>
        </div>

        <div class="card how-to-use">
            <h3><i class="fas fa-question-circle"></i> How To Use Quantum Oracle Pro</h3>
            <ol>
                <li><strong>Select a Prediction Engine</strong> from the dropdown based on current game conditions</li>
                <li>Choose your <strong>prediction type</strong> (Big/Small or Red/Green)</li>
                <li>The system will automatically analyze patterns and display predictions</li>
                <li>Place your bets based on the prediction shown in the main display</li>
                <li>Monitor the <strong>History tab</strong> to track prediction accuracy</li>
                <li>Use <strong>Force Refresh</strong> if data appears stale or delayed</li>
            </ol>
            <p><i class="fas fa-lightbulb"></i> <strong>Pro Tip:</strong> The Holographic AI Matrix has the highest accuracy but may take slightly longer to compute.</p>
        </div>
    </div>

    <script>
        // Global Variables
        let lastPeriodNumber = null;
        let history = [];
        let currentResult = null;
        let pendingResult = null;
        let selectedServer = '';
        let lastTimerUpdate = 0;
        let cachedData = [];
        let lastResults = { bigsmall: [], redgreen: [] };
        let winCount = 0;
        let totalPredictions = 0;

        // Timer and Period Logic
        function updatePeriodAndTimer() {
            const now = new Date();
            const currentTime = now.getTime();

            if (currentTime - lastTimerUpdate < 500) return;
            lastTimerUpdate = currentTime;

            now.setUTCSeconds(now.getUTCSeconds());
            const year = now.getUTCFullYear();
            const month = String(now.getUTCMonth() + 1).padStart(2, '0');
            const day = String(now.getUTCDate()).padStart(2, '0');
            const hours = now.getUTCHours();
            const minutes = now.getUTCMinutes();
            const totalMinutes = hours * 60 + minutes;

            const periodNumber = `${year}${month}${day}1000${10001 + totalMinutes}`;
            const remainingSeconds = 60 - now.getUTCSeconds();

            if (lastPeriodNumber !== periodNumber) {
                console.log('New period generated:', periodNumber);
                if (pendingResult && lastPeriodNumber) {
                    checkPendingResult(lastPeriodNumber).catch(err => console.error('Pending result check failed:', err));
                }
                lastPeriodNumber = periodNumber;
                document.getElementById('period').textContent = `Period: ${periodNumber || 'N/A'}`;
                if (selectedServer) {
                    generateResult(periodNumber);
                } else {
                    document.getElementById('currentResult').textContent = 'Awaiting Engine Selection...';
                    document.getElementById('predictionShort').textContent = '-';
                    document.getElementById('probability').textContent = 'Probability: --%';
                }
            }

            document.getElementById('timer').textContent = `Time: ${String(remainingSeconds).padStart(2, '0')}s`;
            
            // Update last refresh time
            const refreshTime = new Date().toLocaleTimeString();
            document.getElementById('lastRefresh').textContent = refreshTime;
        }

        // Fetch Optimized Data
        async function fetchOptimizedData(maxPages = 10) {
            if (cachedData.length >= 100) {
                return cachedData.slice(0, 100);
            }

            const allData = [];
            const promises = [];
            for (let i = 1; i <= maxPages; i++) {
                promises.push(fetchPage(i));
            }
            try {
                const results = await Promise.all(promises);
                results.forEach(pageData => allData.push(...pageData));
                cachedData = allData;
                console.log('Cached data fetched:', cachedData.length);
                return allData.slice(0, 100);
            } catch (error) {
                console.error('Error fetching optimized data:', error);
                return [];
            }
        }

        // Fetch Page Data
        async function fetchPage(page) {
            try {
                const response = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        pageSize: 10,
                        pageNo: page,
                        typeId: 1,
                        language: 0,
                        random: "4a0522c6ecd8410496260e686be2a57c",
                        signature: "334B5E70A0C9B8918B0B15E517E2069C",
                        timestamp: Math.floor(Date.now() / 1000)
                    })
                });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                return data?.data?.list || [];
            } catch (error) {
                console.error(`Error fetching page ${page}:`, error);
                return [];
            }
        }

        // Fetch Game Result
        async function fetchGameResult(period) {
            try {
                const response = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        pageSize: 10,
                        pageNo: 1,
                        typeId: 1,
                        language: 0,
                        random: "4a0522c6ecd8410496260e686be2a57c",
                        signature: "334B5E70A0C9B8918B0B15E517E2069C",
                        timestamp: Math.floor(Date.now() / 1000)
                    })
                });

                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                const latestResult = data?.data?.list?.find(item => item.issueNumber === period);

                if (latestResult) {
                    const actualNumber = parseInt(latestResult.number, 10) % 10;
                    console.log(`API Result for period ${period}: ${actualNumber}`);
                    return {
                        period: latestResult.issueNumber,
                        result: actualNumber,
                        actualResult: actualNumber >= 5 ? 'BIG' : 'SMALL',
                        colorResult: [0, 2, 4, 6, 8].includes(actualNumber) ? 'RED' : 'GREEN'
                    };
                }
                return null;
            } catch (error) {
                console.error(`Error fetching game result for period ${period}:`, error);
                return null;
            }
        }

        // Advanced Prediction Engines
        async function neuralQuantumEngine(type) {
            const data = await fetchOptimizedData();
            const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : Array(100).fill().map(() => Math.floor(Math.random() * 10));
            
            // Quantum-inspired probability wave analysis
            const probabilityWave = numbers.reduce((wave, n) => {
                wave[n] = (wave[n] || 0) + 1;
                return wave;
            }, {});
            
            // Calculate entropy
            const entropy = -Object.values(probabilityWave).reduce((sum, count) => {
                const p = count / numbers.length;
                return sum + (p > 0 ? p * Math.log2(p) : 0);
            }, 0);
            
            // Quantum superposition state
            const superposition = entropy > 2 ? 'volatile' : 'stable';
            
            let result, probability;
            if (type === 'bigsmall') {
                const bigCount = numbers.filter(n => n >= 5).length;
                const smallCount = numbers.length - bigCount;
                result = bigCount > smallCount ? 'BIG' : 'SMALL';
                probability = 85 + Math.abs(bigCount - smallCount) / numbers.length * 10;
                
                // Quantum tunneling effect for edge cases
                if (superposition === 'volatile' && Math.abs(bigCount - smallCount) < 5) {
                    result = result === 'BIG' ? 'SMALL' : 'BIG';
                    probability -= 5;
                }
            } else {
                const redCount = numbers.filter(n => [0, 2, 4, 6, 8].includes(n)).length;
                const greenCount = numbers.length - redCount;
                result = redCount > greenCount ? 'RED' : 'GREEN';
                probability = 85 + Math.abs(redCount - greenCount) / numbers.length * 10;
                
                if (superposition === 'volatile' && Math.abs(redCount - greenCount) < 5) {
                    result = result === 'RED' ? 'GREEN' : 'RED';
                    probability -= 5;
                }
            }
            
            // Adjust for recent patterns
            if (lastResults[type].slice(0, 3).every(r => r === result)) {
                result = result === 'BIG' ? 'SMALL' : result === 'SMALL' ? 'BIG' : result === 'RED' ? 'GREEN' : 'RED';
                probability -= 10;
            }
            
            return { 
                result, 
                probability: Math.min(99, Math.max(80, Math.round(probability))),
                message: superposition === 'volatile' ? 'Quantum fluctuation detected' : 'Stable quantum state'
            };
        }

        async function fractalPatternScanner(type) {
            const data = await fetchOptimizedData();
            const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : Array(100).fill().map(() => Math.floor(Math.random() * 10));
            
            // Fractal dimension calculation
            const range = Math.max(...numbers) - Math.min(...numbers);
            const mean = numbers.reduce((sum, n) => sum + n, 0) / numbers.length;
            const stdDev = Math.sqrt(numbers.reduce((sum, n) => sum + Math.pow(n - mean, 2), 0) / numbers.length);
            const fractalDimension = Math.log(range) / Math.log(stdDev + 1);
            
            // Pattern recognition
            const patterns = {};
            for (let i = 0; i < numbers.length - 2; i++) {
                const pattern = `${numbers[i]}${numbers[i+1]}`;
                patterns[pattern] = (patterns[pattern] || 0) + 1;
            }
            
            // Predict next based on most common pattern
            const lastTwo = `${numbers[0]}${numbers[1]}`;
            const predictedNext = Object.entries(patterns)
                .filter(([pattern]) => pattern.startsWith(lastTwo[1]))
                .sort((a, b) => b[1] - a[1])[0]?.[0][2] || Math.round(mean);
            
            let result, probability;
            if (type === 'bigsmall') {
                result = predictedNext >= 5 ? 'BIG' : 'SMALL';
                probability = 82 + fractalDimension * 5;
            } else {
                result = [0, 2, 4, 6, 8].includes(predictedNext) ? 'RED' : 'GREEN';
                probability = 82 + fractalDimension * 5;
            }
            
            // Streak breaker
            if (lastResults[type].slice(0, 4).every(r => r === result)) {
                result = result === 'BIG' ? 'SMALL' : result === 'SMALL' ? 'BIG' : result === 'RED' ? 'GREEN' : 'RED';
                probability += 5; // Increased confidence in streak breaking
            }
            
            return { 
                result, 
                probability: Math.min(99, Math.max(80, Math.round(probability))),
                message: fractalDimension > 1.5 ? 'Strong fractal pattern' : 'Weak fractal pattern'
            };
        }

        async function chaosTheoryAnalyzer(type) {
            const data = await fetchOptimizedData();
            const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : Array(100).fill().map(() => Math.floor(Math.random() * 10));
            
            // Lyapunov exponent calculation (simplified)
            const differences = [];
            for (let i = 1; i < numbers.length; i++) {
                differences.push(Math.abs(numbers[i] - numbers[i-1]));
            }
            const avgDifference = differences.reduce((sum, d) => sum + d, 0) / differences.length;
            const lyapunov = Math.log(avgDifference + 1);
            
            // Strange attractor analysis
            const attractor = {
                x: numbers.filter(n => n < 5).length / numbers.length,
                y: numbers.filter(n => [0, 2, 4, 6, 8].includes(n)).length / numbers.length
            };
            
            let result, probability;
            if (type === 'bigsmall') {
                result = attractor.x > 0.5 ? 'SMALL' : 'BIG';
                probability = 80 + Math.abs(attractor.x - 0.5) * 20;
                
                // Chaos adjustment
                if (lyapunov > 0.5) {
                    result = result === 'BIG' ? 'SMALL' : 'BIG';
                    probability -= 5;
                }
            } else {
                result = attractor.y > 0.5 ? 'RED' : 'GREEN';
                probability = 80 + Math.abs(attractor.y - 0.5) * 20;
                
                if (lyapunov > 0.5) {
                    result = result === 'RED' ? 'GREEN' : 'RED';
                    probability -= 5;
                }
            }
            
            return { 
                result, 
                probability: Math.min(99, Math.max(80, Math.round(probability))),
                message: lyapunov > 0.5 ? 'High chaos detected' : 'Stable chaotic system'
            };
        }

        async function temporalFluxPredictor(type) {
            const data = await fetchOptimizedData();
            const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : Array(100).fill().map(() => Math.floor(Math.random() * 10));
            
            // Time-series analysis
            const timeSeries = numbers.map((n, i) => ({ time: i, value: n }));
            const slope = (timeSeries.length * timeSeries.reduce((sum, pt) => sum + pt.time * pt.value, 0) - 
                          timeSeries.reduce((sum, pt) => sum + pt.time, 0) * timeSeries.reduce((sum, pt) => sum + pt.value, 0)) /
                         (timeSeries.length * timeSeries.reduce((sum, pt) => sum + pt.time * pt.time, 0) - 
                          Math.pow(timeSeries.reduce((sum, pt) => sum + pt.time, 0), 2));
            
            // Temporal anomaly detection
            const residuals = timeSeries.map(pt => pt.value - (slope * pt.time));
            const residualStd = Math.sqrt(residuals.reduce((sum, r) => sum + r * r, 0) / residuals.length);
            const anomalies = residuals.filter(r => Math.abs(r) > 2 * residualStd).length;
            
            let result, probability;
            if (type === 'bigsmall') {
                result = slope > 0 ? 'BIG' : 'SMALL';
                probability = 83 + Math.abs(slope) * 100;
                
                // Anomaly adjustment
                if (anomalies > numbers.length * 0.1) {
                    result = result === 'BIG' ? 'SMALL' : 'BIG';
                    probability += 5; // Increased confidence in reversal
                }
            } else {
                const lastRed = numbers.findIndex(n => [0, 2, 4, 6, 8].includes(n));
                const lastGreen = numbers.findIndex(n => ![0, 2, 4, 6, 8].includes(n));
                result = lastRed < lastGreen ? 'RED' : 'GREEN';
                probability = 83 + (Math.max(lastRed, lastGreen) / numbers.length) * 20;
                
                if (anomalies > numbers.length * 0.1) {
                    result = result === 'RED' ? 'GREEN' : 'RED';
                    probability += 5;
                }
            }
            
            return { 
                result, 
                probability: Math.min(99, Math.max(80, Math.round(probability))),
                message: anomalies > 0 ? 'Temporal anomaly detected' : 'Stable time continuum'
            };
        }

        async function holographicAIMatrix(type) {
            const data = await fetchOptimizedData();
            const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : Array(100).fill().map(() => Math.floor(Math.random() * 10));
            
            // Holographic principle analysis (simplified)
            const bigSmallRatio = numbers.filter(n => n >= 5).length / numbers.length;
            const redGreenRatio = numbers.filter(n => [0, 2, 4, 6, 8].includes(n)).length / numbers.length;
            
            // Multi-dimensional correlation
            const correlations = {
                bigRed: numbers.filter(n => n >= 5 && [0, 2, 4, 6, 8].includes(n)).length,
                bigGreen: numbers.filter(n => n >= 5 && ![0, 2, 4, 6, 8].includes(n)).length,
                smallRed: numbers.filter(n => n < 5 && [0, 2, 4, 6, 8].includes(n)).length,
                smallGreen: numbers.filter(n => n < 5 && ![0, 2, 4, 6, 8].includes(n)).length
            };
            
            // Holographic projection
            let result, probability;
            if (type === 'bigsmall') {
                const bigScore = (correlations.bigRed + correlations.bigGreen) / numbers.length;
                const smallScore = (correlations.smallRed + correlations.smallGreen) / numbers.length;
                result = bigScore > smallScore ? 'BIG' : 'SMALL';
                probability = 87 + Math.abs(bigScore - smallScore) * 50;
                
                // Holographic correction
                if (Math.abs(bigScore - smallScore) < 0.1) {
                    const lastThree = numbers.slice(0, 3);
                    const lastTrend = lastThree.filter(n => n >= 5).length > 1.5 ? 'BIG' : 'SMALL';
                    result = lastTrend;
                    probability -= 5;
                }
            } else {
                const redScore = (correlations.bigRed + correlations.smallRed) / numbers.length;
                const greenScore = (correlations.bigGreen + correlations.smallGreen) / numbers.length;
                result = redScore > greenScore ? 'RED' : 'GREEN';
                probability = 87 + Math.abs(redScore - greenScore) * 50;
                
                if (Math.abs(redScore - greenScore) < 0.1) {
                    const lastThree = numbers.slice(0, 3);
                    const lastTrend = lastThree.filter(n => [0, 2, 4, 6, 8].includes(n)).length > 1.5 ? 'RED' : 'GREEN';
                    result = lastTrend;
                    probability -= 5;
                }
            }
            
            // Quantum entanglement adjustment
            if (lastResults['bigsmall'].length > 2 && lastResults['redgreen'].length > 2) {
                const bigSmallStreak = lastResults['bigsmall'].slice(0, 3).every(r => r === result);
                const redGreenStreak = lastResults['redgreen'].slice(0, 3).every(r => r === result);
                
                if (bigSmallStreak || redGreenStreak) {
                    result = result === 'BIG' ? 'SMALL' : result === 'SMALL' ? 'BIG' : result === 'RED' ? 'GREEN' : 'RED';
                    probability += 5; // Increased confidence due to entanglement
                }
            }
            
            return { 
                result, 
                probability: Math.min(99, Math.max(80, Math.round(probability))),
                message: 'Holographic projection complete'
            };
        }

        // Generate Prediction
        async function generateResult(period) {
            console.log('Generating result for period:', period, 'Server:', selectedServer);
            if (!selectedServer || !period) {
                document.getElementById('currentResult').textContent = 'Awaiting Engine Selection...';
                document.getElementById('predictionShort').textContent = '-';
                document.getElementById('probability').textContent = 'Probability: --%';
                console.log('Generation blocked:', { selectedServer, period });
                return;
            }

            document.getElementById('currentResult').textContent = 'Quantum Analysis in Progress...';
            document.getElementById('predictionShort').textContent = '‚åõ';
            document.getElementById('probability').textContent = 'Probability: Calculating...';

            const resultType = document.getElementById('resultType').value || 'bigsmall';
            let prediction;

            try {
                const startTime = Date.now();
                switch (selectedServer) {
                    case 'neural': prediction = await neuralQuantumEngine(resultType); break;
                    case 'fractal': prediction = await fractalPatternScanner(resultType); break;
                    case 'chaos': prediction = await chaosTheoryAnalyzer(resultType); break;
                    case 'temporal': prediction = await temporalFluxPredictor(resultType); break;
                    case 'holo': prediction = await holographicAIMatrix(resultType); break;
                    default: prediction = { result: "No Engine Selected", probability: 0 };
                }

                const elapsed = Date.now() - startTime;
                const delay = Math.max(0, 5000 - elapsed);
                await new Promise(resolve => setTimeout(resolve, delay));

                const displayText = prediction.message
                    ? `${prediction.result} (${prediction.probability}%) - ${prediction.message}`
                    : `${prediction.result} (${prediction.probability}%)`;

                document.getElementById('currentResult').textContent = displayText;
                document.getElementById('predictionShort').textContent = prediction.result.charAt(0);
                document.getElementById('probability').textContent = `Probability: ${prediction.probability}%`;
                currentResult = prediction.result;

                // Update accuracy rate
                totalPredictions++;
                document.getElementById('accuracyRate').textContent = 
                    winCount > 0 ? `${Math.round((winCount / totalPredictions) * 100)}%` : 'Calculating...';

                if (prediction.result !== "Awaiting Next Cycle") {
                    history.unshift({
                        period,
                        predicted: prediction.result,
                        actual: null,
                        status: "Pending",
                        resultType,
                        server: selectedServer,
                        probability: prediction.probability
                    });
                    pendingResult = history[0];
                    lastResults[resultType].unshift(prediction.result);
                    if (lastResults[resultType].length > 5) lastResults[resultType].pop();
                }
                fetchData(1, getActiveTab()); // Update history content
                console.log('Result generated:', displayText);
            } catch (error) {
                console.error("Error in generateResult:", error);
                document.getElementById('currentResult').textContent = 'Quantum Interference Detected';
                document.getElementById('predictionShort').textContent = '‚ö†';
                document.getElementById('probability').textContent = 'Probability: Error';
            }
        }

        // Check Pending Result
        async function checkPendingResult(period) {
            console.log('Checking pending result for period:', period);
            if (!pendingResult || pendingResult.period !== period) return;

            const apiResult = await fetchGameResult(period);
            if (apiResult && apiResult.period === period) {
                let isWin = false;
                if (pendingResult.resultType === 'bigsmall') {
                    pendingResult.actual = apiResult.actualResult;
                    isWin = pendingResult.predicted === apiResult.actualResult;
                } else if (pendingResult.resultType === 'redgreen') {
                    pendingResult.actual = apiResult.colorResult;
                    isWin = pendingResult.predicted === apiResult.colorResult;
                }

                pendingResult.status = isWin ? "WIN" : "LOSS";
                if (isWin) winCount++;
                
                console.log('Pending result checked:', { isWin, status: pendingResult.status });
                fetchData(1, getActiveTab()); // Update history content
                pendingResult = null;
                
                // Update accuracy display
                document.getElementById('accuracyRate').textContent = 
                    winCount > 0 ? `${Math.round((winCount / totalPredictions) * 100)}%` : 'Calculating...';
            }
        }

        // Fetch and Display Data
        async function fetchData(page, tab = 'game') {
            const content = document.getElementById('historyContent');
            content.innerHTML = '<div class="loading">Loading quantum data...</div>';

            document.querySelectorAll('.tabs button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.tabs button[onclick*="${tab}"]`).classList.add('active');

            if (tab === 'game') {
                try {
                    const response = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            pageSize: 10,
                            pageNo: page,
                            typeId: 1,
                            language: 0,
                            random: "4a0522c6ecd8410496260e686be2a57c",
                            signature: "334B5E70A0C9B8918B0B15E517E2069C",
                            timestamp: Math.floor(Date.now() / 1000)
                        })
                    });

                    const data = await response.json();
                    console.log('API Response:', JSON.stringify(data, null, 2));

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    content.innerHTML = '';
                    if (data.code === 0 && data.data && Array.isArray(data.data.list)) {
                        data.data.list.forEach(item => {
                            const period = item.period || item.issue || item.issueNumber || 'N/A';
                            const number = item.number || item.no || item.result || 'N/A';
                            const bigSmall = item.bigSmall || item.big_small || (parseInt(number) >= 5 ? 'BIG' : 'SMALL') || 'N/A';
                            const color = item.color || item.colour || ([0, 2, 4, 6, 8].includes(parseInt(number)) ? 'RED' : 'GREEN') || 'N/A';

                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'history-item';
                            itemDiv.innerHTML = `
                                <div>
                                    <div class="history-label">Period</div>
                                    <div class="history-value">${period.length > 10 ? period.slice(-4) : period}</div>
                                </div>
                                <div>
                                    <div class="history-label">Number</div>
                                    <div class="history-value">${number}</div>
                                </div>
                                <div>
                                    <div class="history-label">Big/Small</div>
                                    <div class="history-value">${bigSmall}</div>
                                </div>
                                <div>
                                    <div class="history-label">Color</div>
                                    <div class="history-value">
                                        <span class="color-dot ${color.toLowerCase() === 'red' ? 'color-red' : 'color-green'}"></span>
                                        ${color}
                                    </div>
                                </div>
                            `;
                            content.appendChild(itemDiv);
                        });
                    } else {
                        console.error('API Error:', data.msg || 'Invalid data structure or code:', data.code);
                        content.innerHTML = '<div class="error">Failed to load history data. Check console for details.</div>';
                    }
                } catch (error) {
                    console.error('Fetch Error:', error);
                    content.innerHTML = '<div class="error">An error occurred while fetching data. Check console for details.</div>';
                }
            } else if (tab === 'my') {
                content.innerHTML = '';
                if (history.length === 0) {
                    content.innerHTML = '<div class="error">No prediction history available.</div>';
                    return;
                }
                
                history.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'history-item';
                    itemDiv.innerHTML = `
                        <div>
                            <div class="history-label">Period</div>
                            <div class="history-value">${item.period.slice(-4)}</div>
                        </div>
                        <div>
                            <div class="history-label">Predicted</div>
                            <div class="history-value">${item.predicted}</div>
                        </div>
                        <div>
                            <div class="history-label">Result</div>
                            <div class="history-value">${item.actual || '--'}</div>
                        </div>
                        <div>
                            <div class="history-label">Status</div>
                            <div class="history-value status-${item.status.toLowerCase()}">${item.status}</div>
                        </div>
                    `;
                    content.appendChild(itemDiv);
                });
            } else {
                content.innerHTML = '<div class="info">Advanced analytics coming soon...</div>';
            }
        }

        // Get Active Tab
        function getActiveTab() {
            const activeButton = document.querySelector('.tabs .active');
            return activeButton ? activeButton.getAttribute('onclick').match(/'(\w+)'/)[1] : 'game';
        }

        // Server Selection
        function updateServerSelection() {
            selectedServer = document.getElementById('serverSelect').value;
            console.log('Selected server:', selectedServer);
            
            // Hide all server info divs
            document.querySelectorAll('.server-info').forEach(div => div.classList.remove('active'));
            
            // Show selected server info
            if (selectedServer) {
                document.getElementById(`${selectedServer}Info`).classList.add('active');
                
                if (lastPeriodNumber) {
                    generateResult(lastPeriodNumber);
                } else {
                    document.getElementById('currentResult').textContent = 'Awaiting Period Data...';
                    document.getElementById('predictionShort').textContent = '-';
                    document.getElementById('probability').textContent = 'Probability: --%';
                }
            } else {
                document.getElementById('currentResult').textContent = 'Awaiting Engine Selection...';
                document.getElementById('predictionShort').textContent = '-';
                document.getElementById('probability').textContent = 'Probability: --%';
            }
        }

        // Force Refresh
        function forceRefresh() {
            cachedData = [];
            lastResults = { bigsmall: [], redgreen: [] };
            if (lastPeriodNumber) {
                generateResult(lastPeriodNumber);
            }
            fetchData(1, getActiveTab());
            
            // Add visual feedback
            const btn = document.querySelector('.pulse');
            btn.innerHTML = '<i class="fas fa-check"></i> Refreshed';
            btn.style.background = 'linear-gradient(to right, #28a745, #20c997)';
            setTimeout(() => {
                btn.innerHTML = '<i class="fas fa-sync-alt"></i> Force Refresh';
                btn.style.background = 'linear-gradient(to right, var(--primary), var(--secondary))';
            }, 2000);
        }

        // Initialize
        setInterval(updatePeriodAndTimer, 1000);
        window.onload = () => {
            console.log('Quantum Oracle Pro initialized successfully');
            fetchData(1, 'game'); // Default to game history
            
            // Add animation to prediction short
            const predictionShort = document.getElementById('predictionShort');
            predictionShort.classList.add('floating');
            
            // Set initial API status
            document.getElementById('apiStatus').textContent = 'Connected';
            document.getElementById('apiStatus').classList.add('glow-text');
        };
    </script>
</body>
</html>